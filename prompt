Here is the file directory, take into consideration of the comments i have added, they add context for you
.
├── assets
│   ├── config.json // ignore this
│   └── enable.txt // enable wordlist, ignore this
├── client
│   ├── public
│   │   ├── client.js
│   │   └── styles.css
│   └── views
│       ├── gamePage.ejs
│       ├── landingPage.ejs
│       └── notFound.ejs
├── loaders
│   ├── routes.js
│   └── server.js
├── models
│   ├── characterCheck.js // ignore this
│   ├── generateRoomID.js // ignore this
│   ├── pullFromArray.js // ignore this
│   ├── room.js
│   └── wordValidator.js // ignore this
├── package.json // ignore this
└── README.md // ignore this

I have made a the main loop but i am struggling with the front end
I need your help with everything under the "client" directory


here are the contents of "routes.js"

const express = require("express");
const rooms = require("./server.js");
const router = express.Router();

// root -> landing page, has a form to enter a roomID or create a room
router.get("/", (req, res) => {
	res.render("landingPage.ejs");
})

// /roomID -> renders the game page (if the game has already started, they will be redirected to the main landingpage and an alert would pop up)
let validRooms = Object.keys(rooms);
for(let i = 0; i < validRooms.length; ++i ) {
	router.get(`/${validRooms[i]}`, async (req, res) => { // might not need async
		return res.render("gamePage.ejs", { roomID: validRooms[i] });
	})
}

module.exports = router

here are the contents of "server.js"

const express = require("express");
const http = require("http");
const socketio = require("socket.io");
const { join } = require("path");

const Room = require("../models/room.js");
const { generateRoomID } = require("../models/generateRoomID.js");
const { pullFromArray } = require("../models/pullFromArray.js");

const routeManager = require("./routes.js");
require("dotenv").config({ path: `.env.${process.env.NODE_ENV}` });

const app = express();
const server = http.createServer(app);
const io = socketio(server);

const port = process.env.port || 3000;

const rooms = {};
module.exports.rooms = rooms;


// while you can argue this is not really needed, you need to understand if someone has the ability to spoof requests the game would break
const playersInRooms = []; // ensures that players cannot join 2 times
const creatorsOfRoom = []; // ensures that creators cannot create again


app.use("/", routeManager);
app.set("view engine", "ejs");
app.set("views", join(__dirname, "../client/views"));
app.set(express.static(join(__dirname, "../client/public")));
app.set("trust proxy", 1);

app.use(function(req, res) {
	res.status(404);
	return res.render("notFound.ejs");
});


io.on("connection", (socket) => {
	let currentRoom;

	socket.on("joinRoom", (roomID) => {
		let playerID = socket.id;
		currentRoom = rooms[roomID];
		// if(currentRoom.gameState !== "waiting") return socket.emit("cannotJoinRoom")
		if(!currentRoom) return socket.emit("RoomDoesNotExist");
		socket.join(roomID);
		currentRoom.addPlayer(playerID);
		return playersInRooms.push(playerID);
	});

	this.lastWord = "",


	socket.on("createRoom", (creatorID) => {
		let newRoom = new Room(creatorID, generateRoomID(creatorID.substring(0,5)));
		rooms[newRoom.roomID] = newRoom;
		creatorsOfRoom.push(creatorID);
		return playersInRooms.push(playerID);
	});



	socket.on("startGame", (roomID) => {
		currentRoom = rooms[roomID];
		if(currentRoom.players.length < 2) return currentRoom.broadcast("notEnoughPlayersToStart");
		startGameLoop(currentRoom);
		return console.log(`game started in ${roomID}`);
	});


	socket.on("endGame", (roomID) => {
		currentRoom = rooms[roomID];
		if(socket.id !== currentRoom.creatorID) return socket.emit("notCreator"); // anticheat
		return currentRoom.endGame();
	});


	socket.on("word", (word, roomID) => {
		currentRoom = rooms[roomID];
		let playerID = socket.id;
		if(currentRoom) {
			if(currentRoom.currentTurn !== playerID) return socket.emit("notYourTurn"); // technically this part is not needed, because i will have a part of the code that broadcasts to everyone in the room it is the next player's turn. However, this is basically an anticheat
			currentRoom.playRound(word.toLowerCase().trim(), playerID);
			return console.log(`${roomID} [gameplay]: submmited ${word}`);
		}
	});



	socket.on("disconnect", (roomID) => {
		currentRoom = rooms[roomID];
		if(currentRoom) {
			// extract player
			let creatorID = currentRoom.creatorID;
			let playerID = socket.id;
			currentRoom.removePlayer(playerID);
			pullFromArray(playersInRooms, playerID);

			// if user is creator
			if(creatorID === playerID) {
				currentRoom.broadcast("creatorLeft");
				pullFromArray(creatorsOfRoom, creatorID);
				delete rooms[currentRoom.roomID];
			}


			// if the user is the current player
			if(currentRoom.currentTurn === playerID) currentRoom.nextTurn(playerID);

			// delete room if not enough players
			if(currentRoom.players.length < 2) {
				currentRoom.broadcast("notEnoughPlayersToContinue");
				delete rooms[currentRoom.roomID];
			}

			return console.log(`[disconnect]: playerID: ${playerID} roomID: ${roomID} creator: ${creatorID}`);
		}
		return console.log("Wait what?!");
	});



});


server.listen(port, () => {
	console.log(`Server running at http://localhost:${port} and process pid is: ${process.pid}`);
});


function startGameLoop(room) {
	room.startGame();
	room.gameLoopInterval = setInterval(() => {
		let currentTime = new Date();
		if(currentTime >= room.expiryTime) {
			room.broadcast("roomExpired");
			delete rooms[room];
		}
	}, 1000);
}

here are the contents of "room.js"

const rooms = require("../loaders/server.js");
const config = require("../assets/config.json");
const { characterCheck } = require("./characterCheck.js");
const { checkWord } = require("./wordValidator.js");

class Room {
	constructor(creatorID, roomID) {
		let currentTime = new Date()
		let endCreationTime = currentDate.setHours(currentDate.getHours() + 2)
		this.creatorID = creatorID,
		this.roomID = roomID,
		this.gameState = "waiting",
		this.players = [creatorID],
		this.playerNumber = [], // player 1 2 3, players added will not be removed even if the player leaves for consistency
		this.wordsUsed = [],
		this.playerPoints = {},
		this.currentTurn = creatorID, // creator of the room has first turn
		this.createdTime = currentTime,
		this.expiryTime = endCreationTime,
		this.startGameTime = "";
	}

	broadcast(eventName, message) {
		io.to(this.roomID).emit(eventName, message);
	}

	sendToPlayer(playerID, event, message) {
		if(!message) return io.to(playerID).emit(event);
		return io.to(playerID).emit(event, message);
	}

	addPlayer(playerID) {
		this.players.push(playerID);
		this.playerNumber.push(playerID);
		this.broadcast("newPlayerJoined", playerID);
	}

	removePlayer(playerID){
		this.players = this.players.filter(player => player.id !== playerID);
		if(this.players.length < 1) {
			delete rooms[this.roomID];
		}
	}

// game mechanics

	usedWord(word) {
		this.wordsUsed.push(word);
	}

	setTurn(playerID) {
		this.currentTurn = playerID;
	}

	nextTurn(playerID) {
		let playerArray = this.players;
		let oldPlayerIndex = playerArray.indexOf(playerID);
		let newPosition = oldPlayerIndex + 1;
		let newPlayer = playerArray[`${newPosition}`];
		if(playerArray.length < newPosition) newPlayer = playerArray[0];
		this.currentTurn = newPlayer;
		this.broadcast("nextTurn", newPlayer);
	}

	startGame() {
		this.broadcast("gameStart", { playerNumber: this.playerNumber }); // at the start of the game the array to help determine the player number is sent, on the client side the player's name will be determined from the array with index of
		this.gameState = "running";
		this.broadcast("nextTurn", this.creatorID);
	}

	endGame() {
		this.broadcast("endGame", {});
		this.gameState = "ended";
		delete rooms[this.roomID];
	}

	addPoints(playerID) {
		let currentScore = this.playerPoints[`${playerID}`];
		if(!currentScore) this.playerPoints[`${playerID}`] = 0;
		this.playerPoints[`${playerID}`] + 1;
		this.broadcast("addedPoint", {playerID: playerID});
	}

	playRound(word, playerID) {
		// check if the word begins with the end of the last word
		let wordArray = this.wordsUsed;
		let latestWord = wordArray[wordArray.length - 1];
		if(latestWord.slice(-1) !== word.charAt(0)) return "wordDoesNotBeginWithLastLetter";
			//this.broadcast("wordDoesNotBeginWithLastLetter", { player: playerID })
			//this.sendToPlayer(playerID, "wordDoesNotBeginWithLastLetter")
			//return this.nextTurn(playerID)
			//return "wordDoesNotBeginWithLastLetter"

		// check if the word has already been used before
		if(wordArray.includes(word)) return "thisWordWasUsedBefore";

		// check if the characters used are valid
		if(!characterCheck(word)) return "invalidCharacters";

		if(!config.acceptedWords.includes(word)) {
			checkWord(word, (err, found) => {
				if(err) {
					this.broadcast("error", err);
					console.error(err);
					return console.log(err);
				}
				if(!found) return "notInEnableDictionary";
			});
			// check if the word actually exists (against a dictionary) (enable)
		}

		//add points
		this.addPoints(playerID);
		// pushes word
		this.usedWord(word);
		this.broadcast("newWord", { wordList: this.wordsUsed, lastWord: word });
		// next turn
		this.nextTurn(playerID);
		return true;
	}

}

module.exports = Room;

help me design the frontend without modifying the frontEnd, thank you